lexer grammar AdaLexer;

options { caseInsensitive = true; }

ABORT             : 'abort';
ABS               : 'abs';
ABSTRACT          : 'abstract';
ACCEPT            : 'accept';
ACCESS            : 'access';
ALIASED           : 'aliased';
ALL               : 'all';
AND               : 'and';
ARRAY             : 'array';
AT                : 'at';
BEGIN             : 'begin';
BODY              : 'body';
CASE              : 'case';
CONSTANT          : 'constant';
DECLARE           : 'declare';
DELAY             : 'delay';
DELTA             : 'delta';
DIGITS            : 'digits';
DO                : 'do';
ELSE              : 'else';
ELSIF             : 'elsif';
END               : 'end';
ENTRY             : 'entry';
EXCEPTION         : 'exception';
EXIT              : 'exit';
FOR               : 'for';
FUNCTION          : 'function';
GENERIC           : 'generic';
GOTO              : 'goto';
IF                : 'if';
IN                : 'in';
INTERFACE         : 'interface';
IS                : 'is';
LIMITED           : 'limited';
LOOP              : 'loop';
MOD               : 'mod';
NEW               : 'new';
NOT               : 'not';
NULL_             : 'null';
OF                : 'of';
OR                : 'or';
OTHERS            : 'others';
OUT               : 'out';
OVERRIDING        : 'overriding';
PACKAGE           : 'package';
PRAGMA            : 'pragma';
PRIVATE           : 'private';
PROCEDURE         : 'procedure';
PROTECTED         : 'protected';
RAISE             : 'raise';
RANGE_            : 'range';
RECORD            : 'record';
REM               : 'rem';
RENAMES           : 'renames';
REQUEUE           : 'requeue';
RETURN            : 'return';
REVERSE           : 'reverse';
SELECT            : 'select';
SEPARATE          : 'separate';
SOME              : 'some';
SUBTYPE           : 'subtype';
SYNCHRONIZED      : 'synchronized';
TAGGED            : 'tagged';
TASK              : 'task';
TERMINATE         : 'terminate';
THEN              : 'then';
TYPE              : 'type';
UNTIL             : 'until';
USE               : 'use';
WHEN              : 'when';
WHILE             : 'while';
WITH              : 'with';
XOR               : 'xor';

WHITESPACE        : [ \t\r\n]+               -> channel(HIDDEN);
LINE_COMMENT      : '--' ~[\r\n]*            -> channel(HIDDEN);

IDENTIFIER        : LETTER+ [A-Z_0-9]*;
NUMERIC_LITERAL   : DECIMAL_LITERAL | BASED_LITERAL;
DECIMAL_LITERAL   : NUMERAL ('.' NUMERAL)? EXPONENT?;
NUMERAL           : DIGIT+ ('_'? DIGIT)*;
EXPONENT          : 'E' '+'? NUMERAL | 'E' '-' NUMERAL;
BASED_LITERAL     : BASE '#' BASED_NUMERAL ('.' BASED_NUMERAL)? '#' EXPONENT?;
BASED_NUMERAL     : EXTENDED_DIGIT ('_'? EXTENDED_DIGIT)*;
EXTENDED_DIGIT    : DIGIT | [A-F];
BASE              : NUMERAL;

CHARACTER_LITERAL : '\'' (~['\\\r\n]) '\'';
STRING_LITERAL    : '"' ('""' | ~('"') )* '"';

fragment LETTER   : [A-Z];
fragment DIGIT    : [0-9];

HASH              : '#';
AMPERSAND         : '&';
LP                : '(';
RP                : ')';
MULT              : '*';
PLUS              : '+';
COMMA             : ',';
MINUS             : '-';
DOT               : '.';
COLON             : ':';
SEMI              : ';';
LT                : '<';
EQ                : '=';
GT                : '>';
US                : '_';
VL                : '|';
DIV               : '/';
EP                : '!';
PS                : '%';
ARROW             : '=>';
DOTDOT            : '..';
EXPON             : '**';
ASSIGN            : ':=';
NE                : '/=';
GE                : '>=';
LE                : '<=';
LLB               : '<<';
RLB               : '>>';
BOX               : '<>';
SQ                : '\'';
